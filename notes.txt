
2 6 5 0 8 7 1 3

a	b

0	8		0
5	7		1
6	1		2
2	3		3
	 		5
	 		6
	 		7
	 		8

pb
pb
pb
pb
sb
rr
rr
sa
rra
sa

0 2 5 6
1 3 7 8

pa
ra 
pa
ra
ra
pa
pa


== 17 operations

------------------logic--------------------

split stack

while !stacks_sorted
	while i < stack.count
		rr 
			if a.0 > a.1 && b.0 > b.1
				ss
			else if a.0 > a.1
				sa
			else if b.0 > b.1
				sb
		i++


1 2 3 4 sa
1 2 4 3 ra
3 1 2 4 sa
3 1 4 2 sa
2 3 1 4
2 3 4 1 
1 2 3 4

1 2 3 4
1 2 4 3
2 4 3 1
4 3 1 2
4 3 2 1

3 0 1
3 1 0

5 4 2


7 5 3 1
6 4 2 0

7 5 3 1 0
6 4 2

0 7 5 3 1
6 4 2

1 0 7 5 3
6 4 2

1 0 7 5 3 2
6 4




8 1 4 6 9 0 5 2

5 2 8 1 4 6 9 0

9 0 5 2 8 1 4 6

9 0 5 2 8 1 4
6

4 9 0 5 2 8 1
6

4 9 0 5 2 8 1 6

6 4 9 0 5 2 8 1


------merge sort------
// edge case: uneven amount of numbers

4 2 8 7 5 0 3 1

-- split into smallest sublists and sort sublists
4 2 8 7 5 0 pb pb
1 3

4 2 8 7 0 5 ss
3 1

4 2 8 7 pb pb
3 1 5 0

--- merge two top sublists
4 2 8 7 0 pa
3 1 5

0 4 2 8 7 ra
3 1 5

0 4 2 8 7 5 pa
3 1

5 0 4 2 8 7 ra
3 1

-- rotate next a sublist in place
8 7 5 0 4 2 ra ra
3 1

-- merge two top sublists
8 7 5 0 4 2 1 pa
3

2 1 8 7 5 0 4 ra ra
3

2 1 8 7 5 0 4 3 pa

4 3 2 1 8 7 5 0 ra ra

-- push next merged sublist onto b
3 2 1 8 7 5 0 4 rra

3 2 1 8 7 5 0 pb
4

2 1 8 7 5 0 3 rra
4

2 1 8 7 5 0 pb
4 3

1 8 7 5 0 2 rra
4 3

1 8 7 5 0 pb
4 3 2

8 7 5 0 1 rra
4 3 2

8 7 5 0 pb
4 3 2 1

-- merge two top sublists
0 8 7 5 ra
4 3 2 1

0 8 7 5 1 pa
4 3 2

1 0 8 7 5 ra
4 3 2

1 0 8 7 5 2 pa
4 3

2 1 0 8 7 5 ra
4 3

2 1 0 8 7 5 3 pa
4

3 2 1 0 8 7 5 ra
4

3 2 1 0 8 7 5 4 pa

-- rotate to correct position
8 7 5 4 3 2 1 0 ra ra ra ra



------quicksort logic------

p4
0 6 4 2 5 7 1 3
-

p6
6 5 7
3 1 2 4 0
pb pb ra ra pb pb ra pb

p7
7
3 1 2 4 0|5 6
ra pb pb

-
3 1 2 4 0|5 6|7
p7
pb

7
3 1 2 4 0|5 6
p5
pa

7|6 5
3 1 2 4 0
p2
pa pa

7|6 5|4 3
1 2 0
p1
rb pa rb rb pa

7|6 5|4 3|2
1 0
p1
rb pa

7|6 5|4 3|2|1
0
p0
rb pa

7|6 5|4 3|2|1|0
pa

== 25 operations


quicksort(current, stacks, vector)
	if (stack.count)
		split_stack(current, stacks, vector)
		quicksort()


4 1 5 3 0 2

start
	mainstack: a
	edges_b++
	edges_a: 0 
	pivot: 4
	a: 5
	b: 2 0 3 1 4
	edges_b: 5 

	mainstack: a
	edges_b++
	edges_a: 0 0
	pivot: 5
	a: 
	b: 2 0 3 1 4 5
	edges_b: 5 1

start a stack empty == true
call b

mainstack: b
edges_a: 0 0
edges_b: 5 1
if (edges_b != 0) true
	if (edges_a + 1 != 1) true
		pivot: 5
		a: 5
		b: 2 0 3 1 4
		edges_a: 0 0 1
		edges_b: 5 1
	call a > edges_b - 1

			mainstack: a
			edges_a: 0 0 1
			edges_b: 5 (1)
			if (edges_a != 0) true
				if (edges_b + 1 != 1) false
				call b > edges_a + 1

						mainstack: b
						edges_a: 0 0 1 0
						edges_b: 5
						if (edges_b != 0) true
							if (edges_a - 1 != 1) true
								pivot: 3
								a: 5 4 3
								b: 2 0 1
								edges_a: 0 0 1 2
								edges_b: 5 (1)
							call a > edges_b - 1

									mainstack: a
									edges_a: 0 0 1 2
									edges_b: 0 (5 1)
									if (edges_a != 0) true
										if (edges_b + 1 != 1) true
											pivot: 3
											a: 5 4
											b: 2 0 1 3
											edges_a: 0 0 1 2
											edges_b: 1 (5 1)
										call b > edges_a + 1

												mainstack: b
												edges_a: 0 0 1 2 0
												edges_b: 1 (5 1)
												if (edges_b != 0) true
													if (edges_a - 1 != 1) true
														pivot: 3
														a: 5 4 3
														b: 2 0 1
														edges_a: 0 0 1 2 1
														edges_b: 1 (5 1)
													call a > edges_b - 1

															mainstack: a
															edges_a: 0 0 1 2 1
															edges_b: 0 (1 5 1)
															if (edges_a != 0) true
																if (edges_b + 1 != 1) false
																call b > edges_a + 1

																		mainstack: b
																		edges_a: 0 0 1 2 1 0
																		edges_b: 0 (1 5 1)
																		if (edges_b != 0) false

																call a > edges_b - 1
																		mainstack: a
																		edges_a: 0 0 1 2 1
																		edges_b: 0 (0 1 5 1)
																		if (edges_b + 1 != 1) true
																			pivot: 3
																			a: 5 4
																			b: 2 0 1 3
																			edges_a: 0 0 1 2 1
																			edges_b: 1 (0 1 5 1)
																		call b > edges_a + 1
																		
																				mainstack: b
																				edges_a: 0 0 1 2 1 0
																				edges_b: 1 (0 1 5 1)
																				if (edges_b != 0) true
																					if (edges_a - 1 != 1) false
																				call a > edges_b - 1

																						mainstack: a
																						edges_a: 0 0 1 2 1 0
																						edges_b: 0 (1 5 1)
																						if (edges_a != 0) false

																				call b > edges_a + 1

																						mainstack: b
																						edges_a: 0 0 1 2 1 0 0
																						edges_b: 1 (0 1 5 1)
																						if (edges_b != 0) true
																							if (edges_a - 1 != 1) false
																								pivot: 3
																								a: 5 4 3
																								b: 2 0 1
																								edges_a: 0 0 1 2 1 0 1
																								edges_b: 1 (0 1 5 1)
																							call a > edges_b - 1

																									mainstack: a
																									edges_a: 0 0 1 2 1 0 1
																									edges_b: 0 (1 0 1 5 1)
																									if (edges_a != 0) true
																										if (edges_b + 1 != 1) false
																									call b > edges_a + 1

																											mainstack: b
																											edges_a: 0 0 1 2 1 0 1 0
																											edges_b: 0 (1 0 1 5 1)
																											if (edges_b != 0) false
																									
																									call a > edges_b - 1

																											mainstack: a
																											edges_a: 0 0 1 2 1 0 1
																											edges_b: 0 0 (1 0 1 5 1)
																											if (edges_a != 0) false

																							call b > edges_a + 1

																									mainstack: b 
																									edges_a: 0 0 1 2 1 0 0 0
																									edges_b: 

>>>>>>>>>>>> this will loop forever



fn b(5)
	pushed 3 of 5 to stack a
	call fn a(3)

		fn a(3)
			pushed 2 of 3 to stack b
			call fn b(2)

				fn b(2)
					pushed 1 of 2 to stack a
					call fn a(1)

						fn a(1)
							base case true
						
					call fn b(2 - 1)

						fn b(1)
							base case true

			call fn a(3 - 2)

				fn a(1)
					base case true
				
	call fn b(5 - 3)

		fn b(2)
			pushed 1 of 2 to stack a
			call fn a(1)

				fn a(1)
					base case true

			call fn b(2 - 1)

				fn b(1)
					base case true



----------bubblesort logic-------------
fn move_to_largest(edge, rotations)
	if (rotations == 0)
		start = top of stack
	else
		start = rotations - 1
	if (edge == 0)
		end = end of stack
	else
		end = top of stack + 1 - edge
	while ()


while ()

fn bubblesort(edge)
	while (pushes < edge)
		rotations = move_to_largest(edge - pushes - rotations, rotations)
		push to other stack
		pushes++


//1. implement merge solution at all edges < 8
//2. implement stack copy function
//3. make merge solution work on copy of stacks instead actual stack, return copy stacks
4. bruteforce until merge copy solution is achieved by testing with another copy of stacks
5. do bruteforce operations on actual stack

----------bruteforce logic-------------
- there are infinite solutions
- max amount of operations for 4 numbers = initial vector count (15?)
- if level < vector count: vector count = level, path = vector, return
- iterate through all branches until level > vector count
- base case: solution true, exit while loop
- undo last step by doing exact reverse move

util functions;
	reverse_operate
		does exact opposite operation of parameter
		vector->count--
	test_operate
		does the operation on stacks
		vector->count++
		adds operation to vector
	path_operate(stacks, vector, path)
		does the found path operations on the original stacks
	copy_array
	check_solution
	int_array_init(count)

level = 0
path->count = 10
vector->count = 0
vector malloc area: 10

find_path(level, solution_state, path, vector, stacks)
	while (operation < 11)
		if (level < path->count)
			test_operate(stacks, vector, operation)
			if (check_solution(solution_state, stacks))
				path->values = copy_array(path->array, vector->array, vector->count)
				path->count = vector->count
				return ;
			else
				find_path(level + 1, solution_state, path, vector, stacks)
		else
			return ;
		reverse_operate(stacks, vector, operation)
		operation++



------------edge < 6 logic--------------
- sort_b sorts to stack a
- sort_a sorts on same stack
- rotates have to be used with caution

sort_b
-
x 0 4 2 1 3
rb rb rb rb

-
4 2 1 3 x 0
pa

0
4 2 1 3 x
rrb rrb rrb

0
3 x 4 2 1
pa pa

0 1 2
3 x 4
rrb

0 1 2
x 4 3
pa pa

0 1 2 3 4

// if return negative, reverse rotate
// if return 0 or positive, rotate

get_highest(top, bottom, stack)
	highest = 0
	while (top)
		if (stack->index[stack->count - top] > highest)
			highest = stack->index[stack->count - top]
		top--
	while (bottom)
		if (stack->index[0 + bottom - 1] > highest)
			highest = stack->index[0 + bottom - 1]
		bottom--
	return (highest)

get_direction(number, stack)
	top = 0
	bottom = 1
	while (stack->index[stack->count - 1 - top] != number)
		top++
	while (bottom && stack->index[0 - 1 + bottom] != number)
		bottom++
	return (bottom - top)

rotate_direction(direction, stacks, vector)
	if (direction < 0)
		operate(stacks, vector, rrb)
	else
		operate(stacks, vector, rb)

insertionsort(edge, swap, stacks, vector)
	highest
	direction
	if (swap == 1)
		top = edge
		bottom = 0
	else
		top = 0
		bottom = edge
	while (edge)
		highest = get_highest(top, bottom, stack)
		direction = get_direction(highest, stack)
		i = 0
		while (stacks[1]->index[stacks[1]->count - 1] != highest)
			rotate_direction(direction, stacks, vector)
		operate(stacks, vector, pa)
		top -= direction
		bottom += direction






